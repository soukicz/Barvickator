<!DOCTYPE html>
<html>
<head>
    <title>Capture Photo</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="jquery.js"></script>
    <script type="text/javascript" charset="utf-8" src="cordova-1.9.0.js"></script>
    <script type="text/javascript" charset="utf-8" src="paleta.js"></script>
    <script type="text/javascript" charset="utf-8" src="chocolatechip-1.0.2.js"></script>
    <style type="text/css">
	html, body {
		padding: 0px;
		margin: 0px;
		height: 100%;
		overflow: hidden;
		-webkit-user-select: none;
	}
	.slider {
		display: inline-block;
		-webkit-box-sizing: border-box;
		-moz-box-sizing: padding-box;
		box-sizing: padding-box;
		-webkit-box-shadow: 2px 2px 4px #666;
		-moz-box-shadow: 2px 2px 4px #666;
		box-shadow: 2px 2px 4px #666;
		height: 9px;
		width: 277px; 
		padding: 1px;
      	-webkit-border-radius: 4px;
      	-moz-border-radius: 4px;
      	border-radius: 4px;
      	background-image: 
      		-webkit-gradient(linear, left top ,left bottom,
			   from(#0a3a86),
			   color-stop(.5, #4c8de7),
			   color-stop(.95, #6babf5),
			   to(#0a3a86)),
		   	-webkit-gradient(linear, left top ,left bottom,
			   	from(#919191),
			   	color-stop(.5, #f0f0f0),
			   	color-stop(.5, #fff),
			   	color-stop(.95, #fff),
			   	to(#919191));
      	background-image: 
      		-moz-linear-gradient(top,
			   #0a3a86,
			   #4c8de7 50%,
			   #6babf5 95%,
			   #0a3a86),
		   	-moz-linear-gradient(top,
			   	#919191,
			   	#f0f0f0 50%,
			   	#fff 50%,
			   	#fff 95%,
			   	#919191);
		background-repeat: no-repeat, repeat-x;
	}
	.thumb {
		position:relative;
		-webkit-box-shadow: 2px 2px 3px #666;
		-moz-box-shadow: 2px 2px 3px #666;
		box-shadow: 2px 2px 3px #666;
		height:20px;
		width:20px;
		left: 0px; 
		top: -6px;
		-webkit-border-radius: 10px;
		-moz-border-radius: 10px;
		border-radius: 10px;
		background-image: 
		   -webkit-gradient(linear, left top, left bottom,
			   from(#aaa),
			   color-stop(.5, #ddd),
			   to(#ccc));
		background-image: 
		   -moz-linear-gradient(top,
			   #aaa,
			   #ddd 50%,
			   #ccc);
		cursor: move;
		-webkit-tap-highlight-color: transparent;
	}
	#redSlider .thumb {
		left: 121px;
	}
	#redSlider {
		-webkit-background-size: 123px 9px, 100% 9px;
		-moz-background-size: 123px 9px, 100% 9px;
		background-size: 123px 9px, 100% 9px;
	}
	#greenSlider .thumb {
		left: 156px;
	}
	#greenSlider {
		-webkit-background-size: 158px 9px, 100% 9px;
		-moz-background-size: 158px 9px, 100% 9px;
		background-size: 158px 9px, 100% 9px;
	}
	#blueSlider .thumb {
		left: 230px;
	}
	#blueSlider {
		-webkit-background-size: 232px 9px, 100% 9px;
		-moz-background-size: 232px 9px, 100% 9px;
		background-size: 232px 9px, 100% 9px;
	}
	.thumb:hover, .thumb.hover {
		background-image: 
		   -webkit-gradient(linear, left top, left bottom,
			   from(#6297f2),
			   color-stop(.5, #0251ae),
			   to(#6297f2));
		background-image: 
		   -moz-linear-gradient(top,
			   #6297f2,
			   #0251ae 50%,
			   #6297f2);
	}
	h1 { 
	   margin: 4px 40px; 
	   padding: 0px;
	   color: #9B5837; 
	   font: bold 24px Helvetica, Arial, Sans-serif; 
	}
	.colorOutput {
		border: solid 1px #000;
		height: 20px;
		width: 20px;
		display: inline-block;
		margin: 20px 0px 0px 20px;
		background-color: rgb(121,156,230);;
	}
	#redColor {
		background-color: rgb(121,0,0);
	}
	#greenColor {
		background-color: rgb(0,156,0);
	}
	#blueColor {
		background-color: rgb(0,0,230);
	}
	.colorRow {
		margin-bottom: 20px;
		-webkit-box-sizeing: border-box;
		padding-left: 20px;
	}
	.finalResult {
		padding-left: 20px;
		text-transform: uppercase;
	}
	.finalResult > span:first-child {
		display: inline-block;
		margin-left: 0px;
	}
	#rgbResult {
		display: inline-block;
		margin-right: 10px;
	}
	
</style>
    <script src="chocolatechip-1.0.2.js" type="text/javascript">
    </script>
    <script type="text/javascript">

        $.ready(function () {

            /**
            *
            * A method to implement drag and drop. This method is attached to the $ object.
            *
            * @method
            * @param {selector} A valid selector for a slider and its thumb.
            * 
            * ### Slider
            *
            * syntax:
            *
            *  $.slider(selector);
            *
            * arguments:
            *
            * - selector:selector A valid selector to the slider with its thumb.
            * 
            * example:
            *
            *  
            * - $.slider('#volumeSlider');
            *
            */
            $.Drag = {
                // The current element being dragged.
                obj: null,
                // The initalization function for the object to be dragged.
                // elem is an element to use as a handle while dragging (optional).
                // elemParent is the element to be dragged, if not specified, 
                // the handle will be the element dragged.
                // minX, maxX, minY, maxY  are the min and max coordinates 
                // allowed for the element while dragging.
                // bSwapHorzRef will toggle the horizontal coordinate system from referencing
                // the left of the element to the right of the element.
                // bSwapVertRef will toggle the vertical coordinate system from referencing
                // the top of the element to the bottom of the element.
                init: function (elem, elemParent, minX, maxX, minY, maxY, bSwapHorzRef, bSwapVertRef) {
                    // Watch for the drag event to start.
                    elem.onmousedown = $.Drag.start;
                    // Figure out which coordinate system is being used.
                    elem.hmode = bSwapHorzRef ? false : true;
                    elem.vmode = bSwapVertRef ? false : true;
                    // Figure out which element is acting as the draggable "handle."
                    elem.root = elemParent && elemParent != null ? elemParent : elem;
                    // Initalize the specified coordinate system.
                    // In order to keep track of the position of the dragged element,
                    // we need to query the inline position values.
                    // Therefore we query the element's style properties
                    // to get those values and attach them inline on the element.
                    if (elem.hmode && isNaN(parseInt(elem.root.style.left))) {
                        elem.root.style.left = $.getStyle(elem.root, "left");
                    }
                    if (elem.vmode && isNaN(parseInt(elem.root.style.top))) {
                        elem.root.style.top = $.getStyle(elem.root, "top")
                    }
                    if (!elem.hmode && isNaN(parseInt(elem.root.style.right))) {
                        elem.root.style.right = $.getStyle(elem.root, "right")
                    }
                    if (!elem.vmode && isNaN(parseInt(elem.root.style.bottom))) {
                        elem.root.style.bottom = $.getStyle(elem.root, "bottom")
                    }
                    // Look to see if the user provided min/max x/y coordinates.
                    elem.minX = typeof minX != 'undefined' ? minX : null;
                    elem.minY = typeof minY != 'undefined' ? minY : null;
                    elem.maxX = typeof maxX != 'undefined' ? maxX : null;
                    elem.maxY = typeof maxY != 'undefined' ? maxY : null;
                    // Add methods for user-defined functions.
                    // The user can attach these to a symbol of the 
                    // element being dragged:
                    /*
                    var targetElem = $.$("#sliderTumb");
                    targetElem.onDragEnd = function() {
                    alert("You finished dragging!");
                    }
                    */
                    // This will fire when you release the dragged element.
                    elem.root.onDragStart = new Function();
                    elem.root.onDragEnd = new Function();
                    // The following will fire continuously while the element
                    // is being dragged. Useful if you want to create a slider that
                    // can update some type of data as it is being dragged.
                    elem.root.onDrag = new Function();
                },
                start: function (e) {
                    // Figure out which object is being dragged.
                    var elem = $.Drag.obj = this;
                    // Normalize the event object.
                    e = $.Drag.fixE(e);
                    // Get the current x and y coordinates.
                    $.Drag.y = parseInt(elem.vmode ? elem.root.style.top : elem.root.style.bottom);
                    $.Drag.x = parseInt(elem.hmode ? elem.root.style.left : elem.root.style.right);
                    // Call the user's function with the current x and y coordinates.
                    elem.root.onDragStart($.Drag.x, $.Drag.y);
                    // Remember the starting mouse position.
                    elem.lastMouseX = e.clientX;
                    elem.lastMouseY = e.clientY;
                    // Do the following if the CSS coordinate system is being used.
                    if (elem.hmode) {
                        // Set the min and max coordiantes, where applicable.
                        if (elem.minX != null) elem.minMouseX = e.clientX - $.Drag.x + elem.minX;
                        if (elem.maxX != null) elem.maxMouseX = elem.minMouseX + elem.maxX - elem.minX;
                        // Otherwise, use a traditional mathematical coordinate system.
                    } else {
                        if (elem.minX != null) elem.maxMouseX = -elem.minX + e.clientX + $.Drag.x;
                        if (elem.maxX != null) elem.minMouseX = -elem.maxX + e.clientX + $.Drag.x;
                    }
                    // Do the following if the CSS coordinate system is being used.
                    if (elem.vmode) {
                        // Set the min and max coordiantes, where applicable.
                        if (elem.minY != null) elem.minMouseY = e.clientY - $.Drag.y + elem.minY;
                        if (elem.maxY != null) elem.maxMouseY = elem.minMouseY + elem.maxY - elem.minY;
                        // Otherwise, we're using a traditional mathematical coordinate system.
                    } else {
                        if (elem.minY != null) elem.maxMouseY = -elem.minY + e.clientY + $.Drag.y;
                        if (elem.maxY != null) elem.minMouseY = -elem.maxY + e.clientY + $.Drag.y;
                    }
                    // Watch for "drag" and "end" events.
                    document.onmousemove = $.Drag.drag;
                    document.onmouseup = $.Drag.end;
                    return false;
                },
                // A function to watch for all movements of the mouse during the drag event.
                drag: function (e) {
                    // Normalize the event object.
                    e = $.Drag.fixE(e);
                    // Get our reference to the element being dragged.
                    var elem = $.Drag.obj;
                    // Get the position of the mouse within the window.
                    var ey = e.clientY;
                    var ex = e.clientX;
                    // Get the current x and y coordinates.
                    $.Drag.y = parseInt(elem.vmode ? elem.root.style.top : elem.root.style.bottom);
                    $.Drag.x = parseInt(elem.hmode ? elem.root.style.left : elem.root.style.right);
                    var nx, ny;
                    // If a minimum X position was set, make sure it doesn't go past that.
                    if (elem.minX != null) ex = elem.hmode ?
				Math.max(ex, elem.minMouseX) : Math.min(ex, elem.maxMouseX);
                    // If a maximum X position was set, make sure it doesn't go past that.
                    if (elem.maxX != null) ex = elem.hmode ?
				Math.min(ex, elem.maxMouseX) : Math.max(ex, elem.minMouseX);
                    // If a minimum Y position was set, make sure it doesn't go past that.
                    if (elem.minY != null) ey = elem.vmode ?
				Math.max(ey, elem.minMouseY) : Math.min(ey, elem.maxMouseY);
                    // If a maximum Y position was set, make sure it doesn't go past that.
                    if (elem.maxY != null) ey = elem.vmode ?
				Math.min(ey, elem.maxMouseY) : Math.max(ey, elem.minMouseY);
                    // Figure out the newly translated x and y coordinates.
                    nx = $.Drag.x + ((ex - elem.lastMouseX) * (elem.hmode ? 1 : -1));
                    ny = $.Drag.y + ((ey - elem.lastMouseY) * (elem.vmode ? 1 : -1));
                    // Set the new x and y coordinates onto the element.
                    $.Drag.obj.root.style[elem.hmode ? "left" : "right"] = nx + "px";
                    $.Drag.obj.root.style[elem.vmode ? "top" : "bottom"] = ny + "px";
                    // Remember  the last position of the mouse.
                    $.Drag.obj.lastMouseX = ex;
                    $.Drag.obj.lastMouseY = ey;
                    // Call the user's onDrag function with the current x and y coordinates.
                    $.Drag.obj.root.onDrag(nx, ny);
                    return false;
                },
                // Function that handles the end of a drag event.
                end: function () {
                    // No longer watch for mouse events (as the drag is done).
                    document.onmousemove = null;
                    document.onmouseup = null;
                    // Call our special onDragEnd function with the x and y coordinates
                    // of the element at the end of the drag event.
                    $.Drag.obj.root.onDragEnd(
				parseInt($.Drag.obj.root.style[$.Drag.obj.hmode ? "left" : "right"]),
				parseInt($.Drag.obj.root.style[$.Drag.obj.vmode ? "top" : "bottom"]));
                    // No longer watch the object for drags.
                    $.Drag.obj = null;
                },
                // A function for normalizing the event object.
                fixE: function (e) {
                    // If the element's properties aren't set, get the values from the equivalent offset properties.
                    if (typeof e.elemX == 'undefined') e.elemX = e.offsetX;
                    if (typeof e.elemY == 'undefined') e.elemY = e.offsetY;
                    return e;
                }
            };

            /**
            *
            * Method to initialize a range slider for mouse interaction.
            * @method
            * @param {selector} A valid selector indicate a range slider (should be unique).
            * @param {object literal} An object literal of values.
            * 
            * ### css
            *
            * syntax:
            *
            *  $(selector).css(style declaration, boolean);
            *
            * arguments:
            *
            * - style:string A valid CSS property/value declaration to add to an element.
            * 
            * @return {Style} Returns CSS property value pairs as inline cssText. 
            * 
            * example:
            *
            *  $("#item").css("font: bold 12pt/14pt Arial, Helvetica, Sans-serif;");
            *  $("#item").css("background-color: red; true");
            *
            */
            $.slider = function (selector, opts) {
                var thumb = $(selector + " > .thumb");
                var slider = $(selector);
                var thumbWidth = parseInt($.getStyle(thumb, "width"));
                var sliderWidth = parseInt($.getStyle(slider, "width"));
                var padding = parseInt($.getStyle(slider, "padding-right"));
                var border = parseInt($.getStyle(slider, "border-right-width"));
                sliderWidth -= padding;
                sliderWidth -= border;
                $.Drag.init(thumb, null, 0, sliderWidth - thumbWidth, opts["top"], opts["top"]);
                for (prop in opts) {
                    if (prop === "onDrag") {
                        thumb.onDrag = function () {
                            this.addClass("hover");
                            opts["onDrag"]();
                        }
                    }
                    if (prop === "onDragEnd") {
                        thumb.onDragEnd = function () {
                            this.removeClass("hover");
                            opts["onDragEnd"]();
                        }
                    }
                }
            };
            // Set up RGB values for the default state of sliders and color swatches.
            $.rgbColor = [121, 156, 230];

            // Method to convert an RGB decimal value to hexadecimal.
            $.rgb2hex = function (hex) {
                if (hex === 0) {
                    return "00";
                } else {
                    return hex.toString(16);
                }
            };
            /**
            *
            * Method to set colors while the range slider's thumb is dragged.
            *
            */
            Element.prototype.setColorFromSlider = function (color) {
                // Make sure we don't go past an RGB value of 255.
                if ($.Drag.x > 255) {
                    $.Drag.x = 255;
                }
                if (color === "red") {
                    $("#" + color + "Color").css("background-color: rgb(" + $.Drag.x + ",0,0)");
                    $.rgbColor[0] = $.Drag.x;
                }
                if (color === "green") {
                    $("#" + color + "Color").css("background-color: rgb(0," + $.Drag.x + ",0)");
                    $.rgbColor[1] = $.Drag.x;
                }
                if (color === "blue") {
                    $("#" + color + "Color").css("background-color: rgb(0,0," + $.Drag.x + ")");
                    $.rgbColor[2] = $.Drag.x;
                }
                $("#rgbColor").css("background-color: rgb(" + $.rgbColor[0] + "," + $.rgbColor[1] + "," + $.rgbColor[2] + ")");
                $("#rgbResult").fill($.rgbColor[0] + ", " + $.rgbColor[1] + ", " + $.rgbColor[2]);
                $("#hexResult").fill("#" + $.rgb2hex($.rgbColor[0]) + $.rgb2hex($.rgbColor[1]) + $.rgb2hex($.rgbColor[2]));
                $("#" + color + "Slider").css("-webkit-background-size:" + ($.Drag.x + 1) + "px 9px, 100% 9px");
                $("#" + color + "Slider").style.MozBackgroundSize = ($.Drag.x + 1) + "px 9px, 100% 9px";
                $("#" + color + "Slider").css("background-size:" + ($.Drag.x + 1) + "px 9px, 100% 9px");
            };

            // Set up three sliders for Red, Green and Blue:
            $.slider("#redSlider", {
                onDrag: function () {
                    $("#redSlider").setColorFromSlider("red");
                },
                // onDragEnd function necessary to remove hover state off of slider thumb when drag ends.
                onDragEnd: function () { },
                top: -6
            });
            $.slider("#greenSlider", {
                // onDragEnd function necessary to remove hover state off of slider thumb when drag ends. 
                onDrag: function () {
                    $("#greenSlider").setColorFromSlider("green");
                },
                // onDragEnd function necessary to remove hover state off of slider thumb when drag ends.
                onDragEnd: function () { },
                top: -6
            });
            $.slider("#blueSlider", {
                onDrag: function () {
                    $("#blueColor").setColorFromSlider("blue");
                },
                onDragEnd: function () { },
                top: -6
            });

            /**
            * Touch enabled support:
            */
            /**
            *
            * Method to set the colors of color swatches and width of the slider progress track when the slider thumb is dragged.
            */
            Element.prototype.setupSliderTouch = function (event) {
                event.preventDefault();
                var el = event.target;
                var touch = event.touches[0];
                curX = touch.pageX - this.parentNode.offsetLeft;
                if (curX <= 0) {
                    curX = 0;
                }
                if (curX > 255) {
                    curX = 255;
                }
            };
            Element.prototype.updateSliderTouch = function (color) {
                this.style.left = curX + 'px';
                if (color === "red") {
                    $("#" + color + "Color").css("background-color: rgb(" + curX + ",0,0)");
                    $.rgbColor[0] = curX;
                }
                if (color === "green") {
                    $("#" + color + "Color").css("background-color: rgb(0," + curX + ",0)");
                    $.rgbColor[1] = curX;
                }
                if (color === "blue") {
                    $("#" + color + "Color").css("background-color: rgb(0,0," + curX + ")");
                    $.rgbColor[2] = curX;
                }

                $("#" + color + "Slider").css("-webkit-background-size:" + (curX + 1) + "px 9px, 100% 9px");
                $("#" + color + "Slider").css("background-size:" + (curX + 1) + "px 9px, 100% 9px");

                $("#rgbColor").css("background-color: rgb(" + $.rgbColor[0] + "," + $.rgbColor[1] + "," + $.rgbColor[2] + ")");
                $("#rgbResult").fill($.rgbColor[0] + ", " + $.rgbColor[1] + ", " + $.rgbColor[2]);
                $("#hexResult").fill("#" + $.rgb2hex($.rgbColor[0]) + $.rgb2hex($.rgbColor[1]) + $.rgb2hex($.rgbColor[2]));
            };

            $("#redSlider > .thumb").bind('touchmove', function (event) {
                this.setupSliderTouch(event);
                this.updateSliderTouch("red");
            });
            $("#greenSlider > .thumb").bind('touchmove', function (event) {
                this.setupSliderTouch(event);
                this.updateSliderTouch("green");
            });
            $("#blueSlider > .thumb").bind('touchmove', function (event) {
                this.setupSliderTouch(event);
                this.updateSliderTouch("blue");
            });
            $$(".colorRow").forEach(function (row) {
                row.bind('touchmove', function (event) {
                    if (row.hasClass("finalResult")) {
                        return false;
                    }
                    //event.preventDefault();
                });
            });

            $$(".button").forEach(function (button) {
                button.bind("touchstart", function () {
                    this.addClass("hover");
                });
            });
            $$(".button").forEach(function (button) {
                button.bind("touchend", function () {
                    this.removeClass("hover");
                });
            });
        });

    </script>
</head>
<body>
    <h1>
        RGB Color Sliders</h1>
    <div class="colorRow">
        <div id="redSlider" class="slider">
            <div class="thumb">
            </div>
        </div>
        <div id="redColor" class="colorOutput">
        </div>
        <span>Red</span>
    </div>
    <div class="colorRow">
        <div id="greenSlider" class="slider">
            <div class="thumb">
            </div>
        </div>
        <div id="greenColor" class="colorOutput">
        </div>
        <span>Green</span>
    </div>
    <div class="colorRow">
        <div id="blueSlider" class="slider">
            <div class="thumb">
            </div>
        </div>
        <div id="blueColor" class="colorOutput">
        </div>
        <span>Blue</span>
    </div>
    <div class="colorRow finalResult">
        <span>Final Color: </span>
        <div id="rgbColor" class="colorOutput">
        </div>
        <br />
        <span>RGB: </span><span id="rgbResult">0, 0, 0</span>
        <br />
        <span>HEX: </span><span id="hexResult">#000000</span>
    </div>
</body>
</html>
